# 节流与防抖

## 节流(throttle)
### 节流定义
规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效(符合首次)

### 应用场景
鼠标不断点击触发，mousedown(单位时间内只触发一次)
监听滚动事件，比如是否滑到底部自动加载更多，用throttle来限制请求


### 触发例子
控制间隔时间1000ms

| 实际触发情况 | 时间(ms) | 防抖触发事件 |
| ------------ | -------- | ------------ |
| ✅ (1)        | 250      | ✅ (1)        |
|              | 500      |              |
| ✅ (2)        | 750      |              |
|              | 1000     |              |
|              | 1250     |              |
| ✅ (3)        | 1500     | ✅ (3)        |
|              | 1750     |              |
| ✅ (4)        | 2000     |              |
|              | 2250     |              |
|              | 2500     | ✅ (4)        |

### 节流源码
```js
function throttle(fun, delay) {
  let last, deferTimer
  return (..._args) => {
      let now = Date.now()
      if (last && now < last + delay) {
          clearTimeout(deferTimer)
          deferTimer = setTimeout(() =>{
            last = now
            fun.apply(this, _args)
          }, delay)
      }else {
          last = now
          fun.apply(this,_args)
      }
  }
}
var mouseThrottle = throttle(()=> {
  console.log('throottle mouseove')
}, 1000)

document.body.addEventListener('mousemove',mouseThrottle,false)
```

## 防抖(debounce)

### 防抖定义
函数会从上一次被调用后，延迟一个单位时间后调用再调用该函数。多次触发的相同事件的触发合并为一次触发（最后一次）

### 应用场景
搜索框，不能用户输入一个字符查询一次。为了节省服务器请求，加入防抖判断用户是否输入完成，才搜索字符串。
window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次（只要停下n微秒就触发事件）。

### 触发例子
控制间隔时间1000ms


| 实际触发情况 | 时间(ms) | 防抖触发事件 |
| ------------ | -------- | ------------ |
| ✅ (1)        | 250      |              |
|              | 500      |              |
| ✅ (2)        | 750      |              |
|              | 1000     |              |
|              | 1250     |              |
|              | 1500     |              |
|              | 1750     | ✅ (2)        |
| ✅ (4)        | 2000     |              |
|              | 2250     |              |
|              | 2500     |              |
|              | 3000     | ✅ (4)        |

### 节流源码
```js
function debounce(fun, delay) {

  // 定时器，用来 setTimeout
  var timer

  // 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fun 函数
  return (...args) => {

    // 每次这个返回的函数被调用，就清除定时器，以保证不执行 fun
    clearTimeout(timer)

    // 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），
    // 再过 delay 毫秒就执行 fun
    timer = setTimeout(() => {
      fun.apply(this, args)
    }, delay)
  }
}
var mouseDebounce = debounce(()=> {
  console.log('throottle mouseove')
}, 1000)

document.body.addEventListener('mousemove',mouseDebounce,false)
```

### 节流与防抖相同点
优化高频率执行js代码的一种手段，对这高频事件进行调用次数进行时间相关限制

### 节流与防抖不相同点
例如下面控制时间在1000ms触发一次（共4次）, 实际触发事件间隔500ms，而且触发时间间隔相同
#### 节流
因为节流函数存在一个闭包记录上一次调用函数时间，用于判断本次触发是否超过间隔时间，只要通过就立即执行，实现无论调用函数怎样触发，保证在单位时间内保证会触发函数一次。


| 实际触发情况 | 时间(ms) | 节流触发事件 |
| ------------ | -------- | ------------ |
| ✅ (1)        | 250      | ✅ (1)        |
|              | 500      |              |
| ✅ (2)        | 750      |              |
|              | 1000     |              |
| ✅ (3)        | 1250     | ✅ (3)        |
|              | 1500     |              |
| ✅ (4)        | 1750     |              |
|              | 2000     |              |
|              | 2250     |              |
|              | 2500     |              |
|              | 2750     | ✅ (4)        |

#### 防抖
因为防抖存在固定的时间间隔限制，而且触发一次后间隔时间重新计时，并且函数不会立即执行，当前的例子，会出现防抖函数只有在最后一次触发才执行情况


| 实际触发情况 | 时间(ms) | 防抖触发事件 |
| ------------ | -------- | ------------ |
| ✅ (1)        | 250      |              |
|              | 500      |              |
| ✅ (2)        | 750      |              |
|              | 1000     |              |
| ✅ (3)        | 1250     |              |
|              | 1500     |              |
| ✅ (4)        | 1750     |              |
|              | 2000     |              |
|              | 2250     |              |
|              | 2500     |              |
|              | 2750     | ✅ (4)        |